#include "Utils/Math/MathConstants.slangh"
import Scene.Scene;
import Scene.ShadingData;
__exported import Utils.Helpers; // For computeRayOrigin()
__exported import Utils.Math.MathHelpers;
__exported import Experimental.Scene.Lights.EnvMapSampler;
__exported import Experimental.Scene.Material.MaterialShading;
__exported import Experimental.Scene.Lights.EmissiveLightSampler;
__exported import Experimental.Scene.Lights.EmissiveLightSamplerHelpers;
__exported import Experimental.Scene.Lights.LightHelpers;
__exported import RenderPasses.Shared.PathTracer.PathData;
__exported import RenderPasses.Shared.PathTracer.PathTracerParams;
__exported import Utils.Sampling.SampleGeneratorInterface;

cbuffer PerFrameCB
{		
	bool  IsInitLight;		// For ReSTIR - to choose an arbitrary light for this pixel after choosing 32 random light candidates
	bool IsTemporalReuse;
	float4x4 LastCameraMatrix;
	uint CandidateCount;
	uint ReservoirPerPixel;
	bool Unbiased;
}

RWTexture2DArray<float4> ReservoirTemporal;
RWTexture2DArray<float4> ReservoirCurr;		// For ReSTIR - need to be read-write because it is also updated in the shader as wellRWTexture2D<float4> gOutput; 
RWTexture2DArray<float4> ReservoirPrev;
RWTexture2DArray<float4> FinalLightPos;
RWTexture2DArray<float4> FinalLightLi;

bool getLightSample<S : ISampleGenerator>(in uint xi, const PathTracerParams params, const EnvMapSampler envMapSampler, const EmissiveLightSampler emissiveSampler, const ShadingData sd, const float3 rayOrigin, inout S sg, out SceneLightSample ls)
{
    float p[3];
    p[0] = 1.f;
    p[1] = 1.f;
    p[2] = 1.f;

    // Normalize probabilities. Early out if zero.
    float sum = p[0] + p[1] + p[2];
    if (sum == 0.f) return false;

    float invSum = 1.f / sum;
    p[0] *= invSum;
    p[1] *= invSum;
    p[2] *= invSum;

    uint LightCount = gScene.getLightCount();
    uint EmissiveCount = gScene.lightCollection.triangleCount;
    float numSamples = 1.f;
    if (xi < LightCount)
    {
        float selectionPdf = p[1] / LightCount; // TODO: Precompute 1.f/lightCount in cbuffer
        // Sample local light source.
        AnalyticLightSample lightSample;
        bool valid = sampleLight(rayOrigin, gScene.getLight(xi), sg, lightSample);
        // Reject sample if lower hemisphere.
        if (!valid || dot(sd.N, lightSample.dir) < kMinCosTheta) return false;
        // Setup returned sample.
        // Analytic lights do not currently have a geometric representation in the scene.
        // Do not worry about adjusting the ray to avoid self-intersections at the light.
        ls.rayDir = ls.dir = lightSample.dir;
        ls.rayDistance = ls.distance = lightSample.distance;
        ls.pdf = selectionPdf * lightSample.pdf;
        ls.Li = lightSample.Li / (selectionPdf * numSamples);

        return true;
    }
    else if (xi < LightCount + EmissiveCount)
    {
        float selectionPdf = p[2];

        // Sample emissive lights.
        TriangleLightSample lightSample;
        bool valid = sampleTriangle(sd.posW, xi - LightCount, sampleNext2D(sg), lightSample);
        float triangleSelectionPdf = 1.f / (float)EmissiveCount;
        lightSample.pdf *= triangleSelectionPdf;

        // Reject sample if lower hemisphere.
        if (!valid || dot(sd.N, lightSample.dir) < kMinCosTheta) return false;

        // Evaluate MIS with BRDF sampling as the other sampling strategy.
        float pdf = selectionPdf * lightSample.pdf;
        float misWeight = 1.f;
        if (kUseMIS && pdf > 0.f)
        {
            float brdfPdf = evalPdfScatter(sd, lightSample.dir);
            misWeight = evalMIS(params, numSamples, pdf, 1, brdfPdf);
        }

        // Compute offset light sample position to reduce self-intersections at the light.
        // We compute the shadow ray parameters based on the offset position.
        float3 offsetPos = computeRayOrigin(lightSample.posW, lightSample.normalW);
        float3 toLight = offsetPos - rayOrigin;
        ls.rayDistance = length(toLight);
        ls.rayDir = normalize(toLight);

        // Setup returned sample.
        ls.dir = lightSample.dir;
        ls.distance = lightSample.distance;
        ls.pdf = pdf;
        ls.Li = pdf > 0.f ? lightSample.Le * misWeight / (pdf * numSamples) : float3(0);

        return true;
    }
    return false;
}


bool generateReSTIRShadowRay<S : ISampleGenerator>(const PathTracerParams params, const EnvMapSampler envMapSampler, const EmissiveLightSampler emissiveSampler, const ShadingData sd, inout PathData path, inout S sg, inout ShadowRay shadowRay, in uint xi, out float3 lightPos, out float3 lightLi)
{
    // Sample the scene lights.
    SceneLightSample ls;
    bool valid = getLightSample(xi, params, envMapSampler, emissiveSampler, sd, path.origin, sg, ls);
    lightLi = ls.Li * path.thp;
    lightPos = ls.rayDistance * ls.rayDir + sd.posW;
    if (valid && any(ls.Li > 0.f))
    {
        float3 Lr = evalBSDFCosine(sd, ls.dir) * ls.Li * path.thp;
        if (any(Lr > 0.f))
        {
            // The sample is valid and has a non-zero contribution.
            // Store ray parameters and unoccluded radiance, weighted by path throughput.
            path.flags |= (uint(PathFlags::shadowRay) << 0);
            shadowRay.rayParams = float4(ls.rayDir, ls.rayDistance);
            shadowRay.Lr = Lr;
            return true;
        }
    }
    return false;
}

float evalPHat(in uint xi, const PathTracerData pt, ShadingData sd, inout PathData path)
{
    SceneLightSample ls;
    getLightSample(xi, pt.params, pt.envMapSampler, pt.emissiveSampler, sd, path.origin, path.sg, ls);
    float3 Lr = evalBSDFCosine(sd, ls.dir) * ls.Li;
    float PHat = length(Lr);

    return PHat;
}

bool update(inout float4 res, uint xi, float w, SampleGenerator sg)
{
	res.g += w;
	res.b += 1;
	if (sampleNext1D(sg) < (w / res.g))
    {
		res.r = xi;
        return true;
    }
    return false;
}

float4 RIS(const PathTracerData pt, ShadingData sd, inout PathData path, const uint count)
{
	float4 r = float4(0.0f);
	uint xi = 0;
	float PHat = 0;
    float PHatFinal = 0;
    uint TotalLightCount = gScene.getLightCount() + gScene.lightCollection.triangleCount;
	for(int i = 0; i < count; i++)
	{
		xi = min(sampleNext1D(path.sg) * TotalLightCount, TotalLightCount - 1);
		PHat = evalPHat(xi, pt, sd, path);
		
		if (update(r, xi, PHat, path.sg))
            PHatFinal = PHat;
	}
	xi = r.r;
	
	//PHat = evalPHat(xi, pt, sd, path);
	
	r.a = 1 / max(PHatFinal, 0.0001f) * (r.g / max(r.b, 0.0001f));

	return r;
}

// float4 CombineReservoirs(ShadingData sd, float4 res[8], uint resCount, SampleGenerator sg)
// {
// 	float4 s = float4(0.0f);	
// 	float M = 0;
// 	uint xi = 0;
// 	float PHat = 0;
// 	for(int i = 0; i < resCount; i++)
// 	{
// 		//res[i].b = min (20.f * res[0].b, res[i].b);
// 		if (20.f * res[0].b < res[i].b)
// 		{
// 			res[i].b = 20.f * res[0].b;
// 			res[i].g *= 20.f * res[0].b / res[i].b;
// 		}
// 		xi = res[i].r;
// 		PHat = evalPHat(sd, xi);
		
// 		update(s, res[i].r, PHat * res[i].a * res[i].b, sg);
// 		M += res[i].b;
// 	}
// 	xi = s.r;
// 	s.b = M;
// 	PHat = evalPHat(sd, xi);
	
// 	s.a = 1 / max(PHat, 0.0001f) * (s.g / max(s.b, 0.0001f));

// 	return s;
// }

// float4 CombineResservoirsUnbiased(ShadingData sd, float4 res[8], float3 q[8], uint resCount, SampleGenerator sg)
// {
// 	float4 s = float4(0.0f);	
// 	float M = 0;
// 	uint xi = 0;
// 	float PHat = 0;
// 	float Z = 0;
// 	for(int i = 0; i < resCount; i++)
// 	{
// 		//res[i].b = min (20.f * res[0].b, res[i].b);
// 		if (20.f * res[0].b < res[i].b)
// 		{
// 			res[i].b = 20.f * res[0].b;
// 			res[i].g *= 20.f * res[0].b / res[i].b;
// 		}
// 		xi = res[i].r;
// 		PHat = evalPHat(sd, xi);
// 		//if (PHat > 0) Z += res[i].b;
// 		update(s, res[i].r, PHat * res[i].a * res[i].b, sg);
// 		M += res[i].b;
// 	}
// 	s.b = M;

// 	for (int i = 0; i < resCount; i++)
// 	{
// 		if (!checkLightHit(q[i], gScene.getLight(s.r).posW))
// 			Z += res[i].b;
// 	}
// 	xi = s.r;
// 	PHat = evalPHat(sd, xi);
// 	// float m = min(1 / Z, 1);
// 	if (Z < 1) Z = M;
	
// 	//s.a = 1 / max(PHat, 0.0001f) * (s.g / max(Z, res[0].b));
// 	s.a = 1 / max(PHat, 0.0001f) * (s.g / Z);


// 	return s;
// }

// bool sampleReSTIRSceneLights<S : ISampleGenerator>(const PathTracerParams params, const EnvMapSampler envMapSampler, const EmissiveLightSampler emissiveSampler, const ShadingData sd, const float3 rayOrigin, const uint numSamples, inout S sg, out SceneLightSample ls)
// {
//     // Set relative probabilities of the different sampling techniques.
//     // TODO: These should use estimated irradiance from each light type. Using equal probabilities for now.
//     // TODO: Refactor the selection pdf code the helpers above for evaluating the individual probabilities.
//     float p[3];
//     p[0] = kUseEnvLight ? 1.f : 0.f;
//     p[1] = kUseAnalyticLights ? 1.f : 0.f;
//     p[2] = kUseEmissiveLights ? 1.f : 0.f;

//     // Normalize probabilities. Early out if zero.
//     float sum = p[0] + p[1] + p[2];
//     if (sum == 0.f) return false;

//     float invSum = 1.f / sum;
//     p[0] *= invSum;
//     p[1] *= invSum;
//     p[2] *= invSum;

//     // Sample based on uniform random number. Rescale u to [0,1) afterwards.
//     float invPdf = 0.f;
//     float u = sampleNext1D(sg);

//     // We use explicit checks for which light types are enabled so that the compiler
//     // can remove the unused code. It won't otherwise since u is unknown at compile time.

//     if (kUseAnalyticLights)
//     {
//         if (u < p[1])
//         {
//             // Sample analytic light source selected uniformly from the light list.
//             // TODO: Sample based on estimated contributions as pdf.
//             u /= p[1]; // Rescale to [0,1)
//             uint lightCount = gScene.getLightCount();
//             uint lightIndex = min(uint(u * lightCount), lightCount - 1);
//             float selectionPdf = p[1] / lightCount; // TODO: Precompute 1.f/lightCount in cbuffer

//             // Sample local light source.
//             AnalyticLightSample lightSample;
//             bool valid = sampleLight(rayOrigin, gScene.getLight(lightIndex), sg, lightSample);

//             // Reject sample if lower hemisphere.
//             if (!valid || dot(sd.N, lightSample.dir) < kMinCosTheta) return false;

//             // Setup returned sample.
//             // Analytic lights do not currently have a geometric representation in the scene.
//             // Do not worry about adjusting the ray to avoid self-intersections at the light.
//             ls.rayDir = ls.dir = lightSample.dir;
//             ls.rayDistance = ls.distance = lightSample.distance;
//             ls.pdf = selectionPdf * lightSample.pdf;
//             ls.Li = lightSample.Li / (selectionPdf * numSamples);

//             return true;
//         }
//         u -= p[1];
//     }

//     if (kUseEmissiveLights)
//     {
//         //if (u < p[2]) // Always true
//         {
//             float selectionPdf = p[2];

//             // Sample emissive lights.
//             TriangleLightSample lightSample;
//             bool valid = emissiveSampler.sampleLight(rayOrigin, sd.N, true, sg, lightSample);

//             // Reject sample if lower hemisphere.
//             if (!valid || dot(sd.N, lightSample.dir) < kMinCosTheta) return false;

//             // Evaluate MIS with BRDF sampling as the other sampling strategy.
//             float pdf = selectionPdf * lightSample.pdf;
//             float misWeight = 1.f;
//             if (kUseMIS && pdf > 0.f)
//             {
//                 float brdfPdf = evalPdfScatter(sd, lightSample.dir);
//                 misWeight = evalMIS(params, numSamples, pdf, 1, brdfPdf);
//             }

//             // Compute offset light sample position to reduce self-intersections at the light.
//             // We compute the shadow ray parameters based on the offset position.
//             float3 offsetPos = computeRayOrigin(lightSample.posW, lightSample.normalW);
//             float3 toLight = offsetPos - rayOrigin;
//             ls.rayDistance = length(toLight);
//             ls.rayDir = normalize(toLight);

//             // Setup returned sample.
//             ls.dir = lightSample.dir;
//             ls.distance = lightSample.distance;
//             ls.pdf = pdf;
//             ls.Li = pdf > 0.f ? lightSample.Le * misWeight / (pdf * numSamples) : float3(0);

//             return true;
//         }
//     }

//     return false;
// }